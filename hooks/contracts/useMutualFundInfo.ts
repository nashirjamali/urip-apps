"use client";

import { useState, useCallback, useEffect, useMemo } from "react";
import { useAccount } from "wagmi";
import { Address } from "viem";
import {
  AssetAllocation,
  MutualFundInfo,
  UseMutualFundInfoReturn,
} from "@/types";
import { getAssetIcon } from "@/lib/assetMapping";

// Mock data for asset allocations (icons will be generated by getAssetIcon)
const MOCK_ASSET_ALLOCATIONS: AssetAllocation[] = [
  {
    tokenAddress: "0x1234567890123456789012345678901234567890" as Address,
    percentage: 25.5,
    assetName: "Apple Inc.",
    assetSymbol: "tAAPL",
    assetPrice: "192.75",
    assetIcon: getAssetIcon("tAAPL", "STOCK"),
    allocationBasisPoints: 2550,
    isActive: true,
    assetType: "STOCK",
    lastUpdated: new Date().toLocaleString(),
  },
  {
    tokenAddress: "0x2345678901234567890123456789012345678901" as Address,
    percentage: 20.0,
    assetName: "Tesla Inc.",
    assetSymbol: "tTSLA",
    assetPrice: "248.42",
    assetIcon: getAssetIcon("tTSLA", "STOCK"),
    allocationBasisPoints: 2000,
    isActive: true,
    assetType: "STOCK",
    lastUpdated: new Date().toLocaleString(),
  },
  {
    tokenAddress: "0x3456789012345678901234567890123456789012" as Address,
    percentage: 18.3,
    assetName: "Alphabet Inc.",
    assetSymbol: "tGOOGL",
    assetPrice: "175.32",
    assetIcon: getAssetIcon("tGOOGL", "STOCK"),
    allocationBasisPoints: 1830,
    isActive: true,
    assetType: "STOCK",
    lastUpdated: new Date().toLocaleString(),
  },
  {
    tokenAddress: "0x4567890123456789012345678901234567890123" as Address,
    percentage: 15.7,
    assetName: "Microsoft Corporation",
    assetSymbol: "tMSFT",
    assetPrice: "420.18",
    assetIcon: getAssetIcon("tMSFT", "STOCK"),
    allocationBasisPoints: 1570,
    isActive: true,
    assetType: "STOCK",
    lastUpdated: new Date().toLocaleString(),
  },
  {
    tokenAddress: "0x6789012345678901234567890123456789012345" as Address,
    percentage: 8.0,
    assetName: "Gold",
    assetSymbol: "tXAU",
    assetPrice: "2658.75",
    assetIcon: getAssetIcon("tGOLD", "COMMODITY"),
    allocationBasisPoints: 800,
    isActive: true,
    assetType: "COMMODITY",
    lastUpdated: new Date().toLocaleString(),
  },
];

// Mock mutual fund info
const MOCK_MUTUAL_FUND_INFO: MutualFundInfo = {
  tokenPricePerURIP: "125.42",
  nav: "125.42",
  totalAssetValue: "15750000.00",
  totalTokens: "125000.00",
  managementFee: 200, // 2.00% in basis points
  lastNavUpdate: new Date().toLocaleString(),
  isActive: true,
  assetAllocations: MOCK_ASSET_ALLOCATIONS,
  totalAllocationPercentage: 100.0,
};

const formatLastUpdated = (timestamp: number): string => {
  const date = new Date(timestamp);
  return date.toLocaleString();
};

/**
 * Hook for fetching URIP mutual fund information (MOCK VERSION)
 * Returns: Token price per URIP, asset allocations with detailed information
 * NOTE: This version uses mock data instead of real API calls
 */
export const useMutualFundInfo = (): UseMutualFundInfoReturn => {
  const { address } = useAccount();

  const [mutualFundInfo, setMutualFundInfo] = useState<MutualFundInfo | null>(
    null
  );
  const [assetAllocations, setAssetAllocations] = useState<AssetAllocation[]>(
    []
  );
  const [isLoadingFund, setIsLoadingFund] = useState(false);
  const [isLoadingAllocations, setIsLoadingAllocations] = useState(false);
  const [fundError, setFundError] = useState<string | null>(null);
  const [allocationsError, setAllocationsError] = useState<string | null>(null);
  const [lastFetched, setLastFetched] = useState<Date | null>(null);

  // Mock function to simulate API delay and potential errors
  const simulateApiCall = useCallback(
    (duration: number = 1000, shouldError: boolean = false): Promise<void> => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          if (shouldError) {
            reject(new Error("Simulated API error"));
          } else {
            resolve();
          }
        }, duration);
      });
    },
    []
  );

  const fetchFundInfo = useCallback(async () => {
    setIsLoadingFund(true);
    setFundError(null);

    try {
      // Simulate API call delay
      await simulateApiCall(800);

      // Create basic fund info (without allocations)
      const basicFundInfo: Omit<
        MutualFundInfo,
        "assetAllocations" | "totalAllocationPercentage"
      > = {
        tokenPricePerURIP: MOCK_MUTUAL_FUND_INFO.tokenPricePerURIP,
        nav: MOCK_MUTUAL_FUND_INFO.nav,
        totalAssetValue: MOCK_MUTUAL_FUND_INFO.totalAssetValue,
        totalTokens: MOCK_MUTUAL_FUND_INFO.totalTokens,
        managementFee: MOCK_MUTUAL_FUND_INFO.managementFee,
        lastNavUpdate: new Date().toLocaleString(), // Always fresh timestamp
        isActive: MOCK_MUTUAL_FUND_INFO.isActive,
      };

      setMutualFundInfo((prev) =>
        prev ? { ...prev, ...basicFundInfo } : null
      );

      return basicFundInfo;
    } catch (error) {
      console.error("Error fetching fund info:", error);
      setFundError(
        error instanceof Error ? error.message : "Failed to fetch fund info"
      );
      return null;
    } finally {
      setIsLoadingFund(false);
    }
  }, [simulateApiCall]);

  const fetchAssetAllocations = useCallback(async () => {
    setIsLoadingAllocations(true);
    setAllocationsError(null);

    try {
      // Simulate API call delay
      await simulateApiCall(1200);

      // Update timestamps to be fresh and regenerate icons
      const updatedAllocations = MOCK_ASSET_ALLOCATIONS.map((allocation) => ({
        ...allocation,
        lastUpdated: new Date().toLocaleString(),
        assetIcon: getAssetIcon(allocation.assetSymbol, allocation.assetType),
        // Simulate slight price fluctuations
        assetPrice: (
          parseFloat(allocation.assetPrice) *
          (0.98 + Math.random() * 0.04)
        ).toFixed(2),
      }));

      setAssetAllocations(updatedAllocations);
      return updatedAllocations;
    } catch (error) {
      console.error("Error fetching asset allocations:", error);
      setAllocationsError(
        error instanceof Error
          ? error.message
          : "Failed to fetch asset allocations"
      );
      return [];
    } finally {
      setIsLoadingAllocations(false);
    }
  }, [simulateApiCall]);

  const updateMutualFundInfo = useCallback(
    (basicInfo: any, allocations: AssetAllocation[]) => {
      if (!basicInfo) return;

      const totalAllocationPercentage = allocations.reduce(
        (total, allocation) => total + allocation.percentage,
        0
      );

      const completeFundInfo: MutualFundInfo = {
        ...basicInfo,
        assetAllocations: allocations,
        totalAllocationPercentage,
      };

      setMutualFundInfo(completeFundInfo);
    },
    []
  );

  const refreshFund = useCallback(async () => {
    const basicInfo = await fetchFundInfo();
    if (basicInfo && assetAllocations.length > 0) {
      updateMutualFundInfo(basicInfo, assetAllocations);
    }
  }, [fetchFundInfo, assetAllocations, updateMutualFundInfo]);

  const refreshAllocations = useCallback(async () => {
    const allocations = await fetchAssetAllocations();
    if (mutualFundInfo && allocations.length > 0) {
      updateMutualFundInfo(mutualFundInfo, allocations);
    }
  }, [fetchAssetAllocations, mutualFundInfo, updateMutualFundInfo]);

  const refreshAll = useCallback(async () => {
    const [basicInfo, allocations] = await Promise.all([
      fetchFundInfo(),
      fetchAssetAllocations(),
    ]);

    if (basicInfo) {
      updateMutualFundInfo(basicInfo, allocations);
      setLastFetched(new Date());
    }
  }, [fetchFundInfo, fetchAssetAllocations, updateMutualFundInfo]);

  // Initialize with mock data on mount
  useEffect(() => {
    refreshAll();
  }, []);

  const totalAssets = useMemo(
    () => assetAllocations.length,
    [assetAllocations]
  );

  const getAssetBySymbol = useCallback(
    (symbol: string): AssetAllocation | undefined => {
      return assetAllocations.find((asset) => asset.assetSymbol === symbol);
    },
    [assetAllocations]
  );

  const getAssetByAddress = useCallback(
    (address: Address): AssetAllocation | undefined => {
      return assetAllocations.find(
        (asset) => asset.tokenAddress.toLowerCase() === address.toLowerCase()
      );
    },
    [assetAllocations]
  );

  const getActiveAssets = useCallback((): AssetAllocation[] => {
    return assetAllocations.filter((asset) => asset.isActive);
  }, [assetAllocations]);

  const getAssetsByType = useCallback(
    (type: string): AssetAllocation[] => {
      return assetAllocations.filter((asset) => asset.assetType === type);
    },
    [assetAllocations]
  );

  const getStockAssets = useCallback((): AssetAllocation[] => {
    return getAssetsByType("STOCK");
  }, [getAssetsByType]);

  const getCommodityAssets = useCallback((): AssetAllocation[] => {
    return getAssetsByType("COMMODITY");
  }, [getAssetsByType]);

  return {
    mutualFundInfo,
    assetAllocations,

    isLoadingFund,
    isLoadingAllocations,

    fundError,
    allocationsError,

    lastFetched,
    totalAssets,

    getAssetBySymbol,
    getAssetByAddress,
    getActiveAssets,
    getAssetsByType,
    getStockAssets,
    getCommodityAssets,

    refreshFund,
    refreshAllocations,
    refreshAll,
  };
};
